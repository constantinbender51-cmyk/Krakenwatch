import os
import json
import time
import requests
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from collections import defaultdict, Counter

# =========================================
# 1. CONFIGURATION
# =========================================
BINANCE_API_URL = "https://api.binance.com/api/v3/klines"
DEFAULT_MODEL_PATH = "BTCUSDT_15m.json"  # Example default
DAYS_TO_FETCH = 60

# =========================================
# 2. MODEL LOADING & DESERIALIZATION
# =========================================

class StrategyModel:
    def __init__(self, strategy_data):
        self.cfg = strategy_data['config']
        self.params = strategy_data['params']
        self.bucket_size = self.params['bucket_size']
        self.b_count = self.cfg['b_count']
        self.seq_len = self.cfg['s_len']
        self.model_type = self.cfg['model']
        
        # Deserialize maps (convert "1|2|3" string keys back to tuples)
        self.abs_map = self._deserialize_map(self.params['abs_map'])
        self.der_map = self._deserialize_map(self.params['der_map'])

    def _deserialize_map(self, raw_map):
        """Converts string keys '1|2' back to tuple keys (1, 2) and values to ints."""
        clean_map = {}
        for k, v in raw_map.items():
            # If key is empty string, skip or handle empty tuple
            if k == "":
                tuple_key = ()
            else:
                tuple_key = tuple(map(int, k.split('|')))
            clean_map[tuple_key] = int(v)
        return clean_map

    def get_bucket(self, price):
        if self.bucket_size <= 0: return 0
        return int(price // self.bucket_size)

def load_model_file(filepath):
    """Loads and parses the JSON model file generated by the training script."""
    if not os.path.exists(filepath):
        print(f"Error: File {filepath} not found.")
        return None

    with open(filepath, 'r') as f:
        data = json.load(f)

    print(f"Loaded {data['asset']} model (Interval: {data['interval']})")
    print(f"Training Accuracy (Holdout): {data.get('holdout_stats', {}).get('accuracy', 0):.2f}%")
    
    strategies = []
    for strat in data['strategies']:
        strategies.append(StrategyModel(strat))
        
    return {
        "asset": data['asset'],
        "interval": data['interval'],
        "strategies": strategies
    }

# =========================================
# 3. PREDICTION LOGIC (Replicating Source)
# =========================================

def get_single_prediction(mode, abs_map, der_map, a_seq, d_seq, last_val):
    """Core lookup logic matching the training script."""
    if mode == "Absolute":
        if a_seq in abs_map:
            return abs_map[a_seq]
    elif mode == "Derivative":
        if d_seq in der_map:
            pred_change = der_map[d_seq]
            return last_val + pred_change
    return None

def predict_strategy(strategy, price_sequence):
    """
    Generates a prediction for a single strategy in the ensemble.
    Returns: (predicted_price, direction) or (None, 0)
    """
    # 1. Discretize sequence
    buckets = [strategy.get_bucket(p) for p in price_sequence]
    
    # 2. Extract context
    s_len = strategy.seq_len
    if len(buckets) < s_len:
        return None, 0
    
    # Slice the last 's_len' buckets
    # Note: Training logic used [i:i+seq_len] to predict [i+seq_len]
    # So we need the last s_len buckets to predict the next one.
    current_slice = buckets[-s_len:] 
    
    a_seq = tuple(current_slice)
    last_val = a_seq[-1]
    last_price = price_sequence[-1]
    
    # Derivative sequence
    if s_len > 1:
        d_seq = tuple(a_seq[k] - a_seq[k-1] for k in range(1, len(a_seq)))
    else:
        d_seq = ()

    # 3. Model Lookup
    mode = strategy.model_type
    abs_map = strategy.abs_map
    der_map = strategy.der_map
    
    pred_val = None
    
    # Combined Logic (from source)
    if mode == "Combined":
        pred_abs = get_single_prediction("Absolute", abs_map, der_map, a_seq, d_seq, last_val)
        pred_der = get_single_prediction("Derivative", abs_map, der_map, a_seq, d_seq, last_val)
        
        dir_abs = 0
        if pred_abs is not None:
            dir_abs = 1 if pred_abs > last_val else -1 if pred_abs < last_val else 0
            
        dir_der = 0
        if pred_der is not None:
            dir_der = 1 if pred_der > last_val else -1 if pred_der < last_val else 0
            
        if dir_abs != 0 and dir_der != 0 and dir_abs == dir_der:
            # If they agree, pick Absolute (arbitrary choice, usually similar)
            pred_val = pred_abs
        elif dir_abs != 0 and dir_der == 0:
            pred_val = pred_abs
        elif dir_der != 0 and dir_abs == 0:
            pred_val = pred_der
    else:
        # Single mode
        pred_val = get_single_prediction(mode, abs_map, der_map, a_seq, d_seq, last_val)

    # 4. Determine Direction
    if pred_val is not None:
        if pred_val > last_val:
            return pred_val, 1
        elif pred_val < last_val:
            return pred_val, -1
            
    return None, 0

def get_ensemble_prediction(strategies, price_sequence):
    """
    Applies the voting and ranking logic from the uploaded script.
    """
    active_signals = []
    max_lookback = max(s.seq_len for s in strategies)
    
    if len(price_sequence) < max_lookback:
        return 0  # Not enough data

    for strat in strategies:
        pred_val, direction = predict_strategy(strat, price_sequence)
        
        if direction != 0:
            active_signals.append({
                "dir": direction,
                "b_count": strat.b_count
            })
    
    if not active_signals:
        return 0

    # 1. Consensus Check (All active signals must agree)
    directions = {x['dir'] for x in active_signals}
    if len(directions) > 1:
        return 0 # Conflict -> Abstain
        
    # 2. Tie-breaker (Source script sorts by bucket_count and takes the first)
    # Lower bucket count = coarser granularity = usually higher priority in this logic
    active_signals.sort(key=lambda x: x['b_count'])
    winner = active_signals[0]
    
    return winner['dir']

# =========================================
# 4. DATA UTILS
# =========================================

def fetch_binance_data(symbol, interval="1m", days=60):
    """Fetches 'days' worth of OHLC data from Binance."""
    print(f"Fetching last {days} days of {interval} data for {symbol}...")
    
    end_time = int(datetime.now().timestamp() * 1000)
    start_time = int((datetime.now() - timedelta(days=days)).timestamp() * 1000)
    
    all_klines = []
    
    while start_time < end_time:
        url = f"{BINANCE_API_URL}?symbol={symbol}&interval={interval}&startTime={start_time}&endTime={end_time}&limit=1000"
        try:
            r = requests.get(url)
            data = r.json()
            if not data or not isinstance(data, list): break
            
            # Keep [timestamp, close]
            batch = [[x[0], float(x[4])] for x in data]
            all_klines.extend(batch)
            
            start_time = data[-1][0] + 1
            time.sleep(0.1) # Be nice to API
            
        except Exception as e:
            print(f"Error fetching data: {e}")
            break
            
    print(f"Fetched {len(all_klines)} candles.")
    return all_klines

def resample_data(klines_1m, target_interval):
    """Resamples 1m [ts, close] data to target pandas offset alias."""
    if target_interval in ["1m", "1min"]:
        return [x[1] for x in klines_1m]
        
    df = pd.DataFrame(klines_1m, columns=['ts', 'price'])
    df['ts'] = pd.to_datetime(df['ts'], unit='ms')
    df.set_index('ts', inplace=True)
    
    # Map '1h' -> '1H', '15m' -> '15min' for pandas
    pandas_freq = target_interval.replace("m", "min").replace("h", "H")
    
    resampled = df['price'].resample(pandas_freq).last().dropna()
    return resampled.tolist()

# =========================================
# 5. BACKTEST ENGINE
# =========================================

def run_backtest(model_data, days=60):
    asset = model_data['asset']
    model_interval = model_data['interval']
    strategies = model_data['strategies']
    
    # 1. Fetch High Res Data
    raw_data = fetch_binance_data(asset, "1m", days)
    if not raw_data: return

    # 2. Resample to Model Interval
    prices = resample_data(raw_data, model_interval)
    print(f"Resampled to {len(prices)} {model_interval} candles.")
    
    # 3. Walk-Forward Simulation
    balance = 1000.0  # Starting cash
    position = 0      # 0 = flat, 1 = long, -1 = short (simplified)
    trades = 0
    wins = 0
    pnl_log = []
    
    # We need at least max_seq_len data points to start predicting
    max_seq = max(s.seq_len for s in strategies)
    
    print("\nRunning Backtest...")
    
    # Loop through prices
    for i in range(max_seq, len(prices) - 1):
        # Current window of history known at time i
        history = prices[:i+1]
        current_price = history[-1]
        next_price = prices[i+1] # The "future" price we are predicting against
        
        # Get signal
        signal = get_ensemble_prediction(strategies, history)
        
        # Trade Logic (Simple Stop-and-Reverse or 1-candle hold)
        # Here we assume a 1-candle trade: Enter at Close[i], Exit at Close[i+1]
        if signal != 0:
            trades += 1
            
            # Calculate % return
            pct_change = (next_price - current_price) / current_price
            
            # If signal was 1 (Long), we want price to go up.
            # If signal was -1 (Short), we want price to go down.
            trade_return = pct_change * signal 
            
            # Update metrics
            if trade_return > 0:
                wins += 1
            
            balance *= (1 + trade_return)
            pnl_log.append(trade_return)

    # 4. Reporting
    accuracy = (wins / trades * 100) if trades > 0 else 0
    total_return = (balance - 1000.0) / 1000.0 * 100
    
    print(f"\n=== BACKTEST RESULTS ({asset} {model_interval}) ===")
    print(f"Duration: {days} Days")
    print(f"Total Trades: {trades}")
    print(f"Accuracy:     {accuracy:.2f}%")
    print(f"Net PnL:      {total_return:.2f}%")
    print(f"Final Equity: ${balance:.2f}")

# =========================================
# 6. MAIN
# =========================================

if __name__ == "__main__":
    # --- Instructions ---
    # 1. Ensure you have the .json model file in the same directory.
    # 2. Update filename below.
    
    model_filename = "BTCUSDT_15m.json" # Change this to your actual file name
    
    if not os.path.exists(model_filename):
        print(f"File '{model_filename}' not found. Please provide the correct path.")
        # Create a dummy file for demonstration if needed? 
        # No, better to warn user to run the trainer first.
    else:
        loaded_model = load_model_file(model_filename)
        if loaded_model:
            # Run the backtest
            run_backtest(loaded_model, DAYS_TO_FETCH)
            
            # Example: Predict on a manual sequence (last 20 prices)
            # Fetch just a tiny bit of data for a live demo
            print("\n--- Live Prediction Test ---")
            recent_data = fetch_binance_data(loaded_model['asset'], "1m", 1) 
            # Note: Real usage would require resampling recent data to match model interval
            # This is just a placeholder for the logic.
